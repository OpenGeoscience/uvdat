import datetime

from celery import shared_task
from django.conf import settings
from django.contrib.gis.geos import LineString, Point

from geoinsight.core.models import (
    Dataset,
    Layer,
    LayerFrame,
    Network,
    NetworkEdge,
    NetworkNode,
    TaskResult,
    VectorData,
)
from geoinsight.core.tasks.data import create_vector_features
from geoinsight.core.tasks.networks import geojson_from_network

from .analysis_type import AnalysisType


class CreateRoadNetwork(AnalysisType):
    def __init__(self):
        super().__init__()
        self.name = 'Create Road Network'
        self.description = 'Leverage OSMnx to create a road network for a target location'
        self.db_value = 'create_road_network'
        self.input_types = {'location': 'string'}
        self.output_types = {'roads': 'Dataset'}
        self.attribution = 'https://osmnx.readthedocs.io/en/stable/'

    @classmethod
    def is_enabled(cls):
        return settings.GEOINSIGHT_ENABLE_TASK_CREATE_ROAD_NETWORK

    def get_input_options(self):
        return {'location': []}

    def run_task(self, *, project, **inputs):
        location = inputs.get('location')
        result = TaskResult.objects.create(
            name=f'Create Road Network for {location}',
            task_type=self.db_value,
            inputs=inputs,
            project=project,
            status='Initializing task...',
        )
        create_road_network.delay(result.id)
        return result


def metadata_for_row(row):
    return {
        k: v
        for k, v in row.to_dict().items()
        if k not in ['osmid', 'geometry', 'ref'] and str(v) != 'nan'
    }


@shared_task
def create_road_network(result_id):
    import osmnx

    result = TaskResult.objects.get(id=result_id)
    try:
        location = result.inputs.get('location')
        if location is None:
            raise ValueError('location not provided')

        result.write_status('Fetching road data via OSMnx...')
        roads = osmnx.graph_from_place(location, network_type='drive')
        road_nodes, road_edges = osmnx.graph_to_gdfs(roads)

        result.write_status('Saving results to database...')
        name = f'Road Network for {location}'
        existing_count = Dataset.objects.filter(name__icontains=name).count()
        if existing_count:
            name += f' ({existing_count + 1})'
        dataset = Dataset.objects.create(
            name=name,
            description='Network generated by OSMnx from OpenStreetMap data',
            category='transportation',
            metadata={'creation_time': datetime.datetime.now(datetime.timezone.utc).isoformat()},
        )
        dataset.set_tags(['analytics', 'osmnx', 'network'])
        vector_data = VectorData.objects.create(
            name=f'{location} Roads Vector Data', dataset=dataset
        )
        layer = Layer.objects.create(name=f'{location} Roads', dataset=dataset)
        LayerFrame.objects.create(name='Roads', layer=layer, vector=vector_data)
        network = Network.objects.create(
            name=f'{location} Road Network',
            category='roads',
            vector_data=vector_data,
            metadata={'source': 'Created with OSMnx'},
        )

        for _, edge_data in road_edges.iterrows():
            edge_geom = edge_data['geometry'].coords
            start = edge_geom[0]
            end = edge_geom[-1]
            edge_name = edge_data['name']
            if str(edge_name) == 'nan' or len(str(edge_name)) < 2:
                # If name is invalid, write new name string
                edge_name = 'Unnamed Road at {:0.4f}/{:0.4f}'.format(
                    *edge_geom[int(len(edge_geom) / 2)]
                )

            start_node_data = road_nodes.loc[
                (road_nodes['x'] == start[0]) & (road_nodes['y'] == start[1])
            ].iloc[0]
            end_node_data = road_nodes.loc[
                (road_nodes['x'] == end[0]) & (road_nodes['y'] == end[1])
            ].iloc[0]

            start_node, created = NetworkNode.objects.get_or_create(
                network=network,
                name='{:0.5f}/{:0.5f}'.format(*start),
                location=Point(*start),
            )
            start_node.metadata = metadata_for_row(start_node_data)
            start_node.save()
            end_node, created = NetworkNode.objects.get_or_create(
                network=network,
                name='{:0.5f}/{:0.5f}'.format(*end),
                location=Point(*end),
            )
            end_node.metadata = metadata_for_row(end_node_data)
            end_node.save()
            edge, created = NetworkEdge.objects.get_or_create(
                network=network,
                name=edge_name,
                directed=edge_data['oneway'],
                from_node=start_node,
                to_node=end_node,
                line_geometry=LineString(*[Point(*p) for p in edge_geom]),
            )
            edge.metadata = metadata_for_row(edge_data)
            edge.save()

        vector_data.write_geojson_data(geojson_from_network(dataset))
        create_vector_features(vector_data)
        vector_data.get_summary()

        result.outputs = dict(roads=dataset.id)
    except Exception as e:
        result.error = str(e)
    result.complete()
